%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contents: Things you need to know
% $Id: appendix1.tex,v 1.1 2008/05/07 06:59:43 hanqi Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\chapter{Things You Need to Know}
\chapter{附录1：Linux C程序开发工具}

\section{Linux文件系统结构}
典型的Linux文件系统是一个单根树型结构，主要包括以下一些目录：
\begin{itemize}
\item /bin
  bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着使用者最经常使用的命令。
  例如cp、ls、cat，等等；
\item /boot
  这里存放的是启动Linux时使用的一些核心文件；
\item /dev
  dev是device（设备）的缩写，这个目录下是所有Linux的外部设备。例如：/dev/hda代表第
  一个物理IDE硬盘；
\item /etc
  这个目录用来存放系统管理所需要的配置文件和子目录；
\item /home
  用户的主目录；
\item /lib
  这个目录里存放着系统最基本的动态链接共享库，几乎所有的应用程序都须要用到这些共享
  库；
\item /mnt
  这个目录是让用户临时挂载其它文件系统用的；
\item /proc
  这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取
  系统信息；
\item /root
  系统管理员（也叫超级用户）的主目录；
\item /sbin
  这里存放的是系统管理员使用的管理程序；
\item /tmp
  用来存放一些临时文件的地方；
\item /var
  这个目录中存放着那些不断在扩充着的东西，那些经常被修改的目录可以放在这个目录下；
\item /usr
  这是最庞大的目录，Linux的应用程序和文件几乎都存放在这个目录下。其中包含以下子目
  录：
  \begin{itemize}
  \item /usr/X11R6
    存放X-Window的目录；
  \item /usr/bin
    存放应用程序；
  \item /usr/sbin
    给超级用户使用的一些管理程序；
  \item /usr/doc
    存放Linux文档的目录；
  \item /usr/include
    存放Linux下开发和编译应用程序需要的头文件；
  \item /usr/lib
    存放一些常用的动态链接共享库和静态档案库；
  \item /usr/local
    这是提供给一般用户的/usr目录，大多数本地软件都安装在这里；
  \item /usr/man
    man在Linux中是帮助的同义词，这里就是帮助文档的存放目录；
  \item /usr/src
    Linux的内核源代码存放的目录。
\end{itemize}
\end{itemize}

\section{代码编辑器}
emacs和vi是Linux系统上两个老牌的编辑器，这两个编辑器的掌握都需要一定时间的学习，
但是一旦掌握了它们的用法，就很容易成为它的忠实
用户，因为这两个编辑器的功能实在非常强大。
gedit是gnome窗口管理器套件的默认编辑器，目前的版本也已经实现了语法加亮等功能，做
为简单的程序编辑器也完全能够满足要求。下面我们就简单介绍一下如何在龙芯福珑电脑上
使用这三种编辑器编辑C源文件。

\subsection{gedit}
龙芯福珑电脑预装的Debian linux操作系统使用gnome做为默认的桌面管理器，gedit是
gnome桌面的小型文本编辑器。目前gedit支持多种编程语言的语法加亮、拼写检查、文档统
计、查找/替换、标签式多文档等功能，做为一个基本的C源代码编辑器完全能够胜任的。

\begin{figure}[htbp]
\centering
\includegraphics[width=3.5in]{./figures/app3/gedit}
\caption{gedit编辑C源代码} 
\label{fig_app_3_1}
\end{figure}

在福珑电脑上打开gedit编辑器有两种方式：第一是直接通过菜单“附件$\rightarrow$文本编
辑器”打开，第二则是直接在终端上打gedit命令。gedit的使用非常简单，具有标准的菜单
和工具栏，工具栏上有常用的新建/打开/保存文件、撤销/重做、拷贝/复制/粘贴以及查找/
替换等快捷按钮，可以通过“编辑$\rightarrow$首选项$\rightarrow$语法突出显示”修改
语法加亮的设置。图\ref{fig_app_3_1}是gedit编辑C代码的外观。总之，gedit是一个比较
适合初学者，容易上手的编辑器。

\subsection{vi}
vi是所有UNIX系统都会提供的屏幕编辑器，它提供了一个视窗设备，通过它可以编辑文件。
vi的特点是体积小启动快，专注于文本编辑。vi是有模式的编辑器，
vi工作时可分为三种操作状态，分别是命令模式（Command mode）、插入模式（Insert mode）和底线命令模式（Last line mode），各模式的功能区分如下：
\begin{itemize}
\item 命令模式：控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入Insert
  mode下，或者到Last line mode；
\item 插入模式：只有在插入模式下，才可做文字数据输入，按Esc键可以回到命令模式；
\item 底线命令模式：这种模式下可以储存文件或离开编辑器，也可设置编辑环境，如寻找
  字符串、列出行号等。
\end{itemize}
有模式编辑器容易使人迷惑现在在那个模式下，在模式间频繁转换也多少会令人厌烦，但是
有模式的编辑器也有其特有的优点，vi可以有更多的按键用于命令，几乎所有的时间手指一
般都停留在基本位置附近，故而操作简洁、效率高，很多操作在vi中需要按键的次数都最少
的。下面我们简单的介绍一下vi的基本操作。

首先在控制台输入命令vi或者vim（一种比较流行的vi的改进版），打开vi编辑器，或者在
其后跟随要打开的文件名，直接用vi打开该文件，如图\ref{fig_app_3_2}所示。
\begin{figure}[htbp]
\centering
\includegraphics[width=3.5in]{./figures/app3/vi-1}
\caption{用vi编辑器编辑C源代码} 
\label{fig_app_3_2}
\end{figure}

使用vi编辑器最先要学会的就是如何在vi的三种模式之间进行切换：
在命令模式下按“i”、“a”或“o”中的任何一个键就可进入插入模式，这时候就可以输
入文字了。这三个键的区别在于：
\begin{itemize}
\item i：插入，从目前光标所在之处插入所输入的文字；
\item a：增加，目前光标所在的下一个字开始输入文字；
\item o：插入新的一行，从行首开始输入文字。
\end{itemize}
按Esc键可以从插入模式切换回命令模式，vi比较特别的一点是，在插入模式下只能写入字
符，在命令模式下才可以删除字符，因此如果发现打错字了，想用光标键往回移动，将该字
删除，就要按Esc键转换回Command mode，再删除文字。
在命令模式下，按冒号“:”键可以进入底线命令模式。
如果弄不清出当前处于什么模式，可以按Esc键回到命令模式，再从命令模式进入想要的模
式。

下面按照功能介绍一些常用的功能键：
\begin{enumerate}
\item 移动光标：
  \begin{enumerate}
  \item 可以直接用键盘上的光标键来上下左右移动；
  \item h、j、k、l，分别控制光标左、下、上、右移一格；
  \item Ctrl+B：屏幕往后移动一页；
  \item Ctrl+F：屏幕往前移动一页；
  \item Ctrl+U：屏幕往后移动半页；
  \item Ctrl+D：屏幕往前移动半页；
  \item w：光标跳到下个词的开头；
  \item e：光标跳到下个词的字尾；
  \item b：光标回到上个词的开头；
  \item \verb=$=：移到光标所在行的行尾；
  \item \verb=^=：移到该行第一个非空白的字符；
  \item 0：移到该行的开头位置；
  \end{enumerate}
\item 删除字符：
  \begin{enumerate}
  \item x：每按一次删除光标所在位置的后面一个字符；
  \item \#x：删除光标所在位置的后面\#个字符；
  \item X：大字的X，每按一次删除光标所在位置的前面一个字符；
  \item \#X：删除光标所在位置的前面\#个字符；
  \item dd：删除光标所在行；
  \item \#dd：删除从光标所在的该行往下数\#行的文字；
  \end{enumerate}
\item 复制、粘贴：
  \begin{enumerate}
  \item yw：将光标所在处到字尾的字符复制到缓冲区中；
  \item p：将缓冲区内的字符粘贴到光标所在位置；
  \item yy：复制光标所在行；
  \item \#yy：拷贝从光标所在的该行往下数\#行的文字；
  \end{enumerate}
\item 撤销、重复执行：
  \begin{enumerate}
  \item u：撤销操作；
  \item .：重复执行上一次的操作；
  \end{enumerate}
\item 取代字符：
  \begin{enumerate}
  \item r：取代光标所在处的字符；
  \item R：取代字符直到按Esc为止；
  \end{enumerate}
\item 保存、退出：
  \begin{enumerate}
  \item w：在底线命令模式提示符号“：”后按w即可将文件存起来；
  \item \#,\# w filename：如果想摘取文章的某一段，存成另一个文件，可用这个指令。
    \#代表始末行号，例如30,50 w nice，将正在编辑文件的第30~50行存成名为nice文件；
  \item q：退出，搭配“!”强置退出，如“q!”；
  \item qw：退出并保存文件。
  \end{enumerate}
\end{enumerate}

\subsection{emacs}
emacs全称GNU emacs，GNU emacs是GNU计划下的第一个产品，emacs为 Editor MACros 的缩
写。是由自由软件运动的创始人Richard Stallman于1975年在MIT开始撰写的。GNU emacs是
由C与LISP语言写成的，目前emacs有多种版本可适合不同的操作系统平台，

emacs不仅仅是一个编辑器，更确切的说它是一个以编辑器为主干的环境软件。一般的软件
都是将编辑器视为一个附属功能，只有emacs以编辑器为基石，在其上发展其它的功能，比
如阅读email和新闻组、浏览网页、管理文件目录、作为网页服务器、远程编辑文件、记录
日程、约会提醒、电子日历、查字典、ICQ聊天、播放amp3等等。当然，用emacs编辑、编译、
调试C程序也是它的一部分功能，事实上，本书就是在emacs中编写的。图
\ref{fig_app_3_3}所示为用emacs编辑C源代码。

\begin{figure}[htbp]
\centering
\includegraphics[width=3.5in]{./figures/app3/emacs}
\caption{用emacs编辑器编辑C源代码} 
\label{fig_app_3_3}
\end{figure}

emacs的各种操作大多通过一些组合键实现，下面简要介绍一下emacs常用的一些组合键，其
中的C表示Ctrl键，M表示Meta键或者Alt键：
\begin{enumerate}
\item 移动光标：
  \begin{enumerate}
  \item C-f，C-b：以字符为单位移动；
  \item M-f，M-b：以单词为单位移动；
  \item C-a，C-e：移动到行首，行末；
  \item M-m：移动到第一个非空格字符；
  \item M-a，M-e：移动到句子头，句子尾；
  \item M-\{，M-\}：移动到段落头，段落尾；
\item C-v，M-v：翻页；
\item M-\verb=<=，M-\verb=>=：到文件头和文件尾； 
  \end{enumerate}
\item 删除：
  \begin{enumerate}
  \item C-d：删除光标位置的单个字符；
  \item M-d：删除光标位置后的一个单词；
  \item C-k：删除光标后的一行；  
  \end{enumerate}
\item 复制、粘贴：
  \begin{enumerate}
  \item C-Space：Ctrl加空格，开始选择文字区域；
  \item C-@：与C-Space等价；
  \item M-w：拷贝；
  \item C-w：剪切；
  \item C-y：粘贴；
  \end{enumerate}
\item 撤销操作：
  \begin{enumerate}
  \item C-\_：撤销操作；
  \end{enumerate}
\item 多窗口/格操作：
  \begin{enumerate}
  \item C-x 5 2：打开一个新emacs窗口；
  \item C-x 5 0：关闭当前的emacs窗口；
  \item C-2：水平分割窗口为两个窗格；
  \item C-3：竖直分割窗口为两个窗格；
  \item C-1：保持光标所在窗格，关闭其它窗格；
  \end{enumerate}
\item 打开文件：
  \begin{enumerate}
  \item C-x C-f：打开文件；
  \end{enumerate}
\item 保存、退出：
  \begin{enumerate}
  \item C-x C-s：保存文件；
  \item C-x C-c：退出emacs。
  \end{enumerate}
\end{enumerate}
关于更多的emacs操作，可以参考emacs的联机帮助，用组合键“C-h t”即可打开emacs的联
机教程，按照联机教程操作一遍，就可以基本掌握emacs的基本操作。

\section{make与Makefile文件}
Linux系统上很多软件包都是使用make程序和Makefile文件来实现自动编译的，Makefile文件
描述了程序中各个文件之间的联系，执行make命令就可以自动的按照设定好的逻辑去编译生
成整个程序或者部分程序。make程序能自动确定一个软件包的哪些部分需要重新编译，并用
指定的命令去编译它们。使用make不仅仅减少编译程序所花费的时间，更重要的是简化了编
译和维护的工作，是开发Linux程序必不可少的工具。

要使用make，必须编写一个Makefile文件，它描述了软件包中各个文件之间的联系，提供了
更新每个文件的命令。在一个软件包中，通常是可执行文件由连接目标文件而更新，而目标
文件由编译源文件而更新。当一个适当的makefile存在时，每次我们改变某些源文件，只需
要用简单的shell命令：make即可完成所有必须的重新编译。

make程序可以使用-f选项指定一个makefile，如果没有使用-f选项，make就会在当前目录下
按顺序寻找下列文件：GNUmakefile、makefile、Makefile，推荐使用Makefile。

一个Makefile文件是一组依赖关系和依赖规则的集合，所谓依赖关系是用来说明某个目标依
赖哪些文件，而依赖关系具体描述了如何用这些文件生成这个目标，目标一般是一个可执行
程序。

依赖关系书写的规则是：目标文件名，冒号，空格，依赖文件列表。例如我们有如下的几个
文件：
\begin{verbatim}
  /* main.c */
  #include "h1.h"
  ... ...
  /* f1.c */
  #include "h1.h"
  #include "h2.h"
  ... ...
  /* f2.c */
  #include "h2.h"
  #include "h3.h"
  ... ...
\end{verbatim}
main.c使用了h1.h中定义的函数，h1.h中的函数在f1.c中实现，f1.c又依赖h2.h，
h2.h中的函数在f2.c中实现，而f2.c依赖h2.h和h3.h。于是它们的依赖关系就应该写成：
\begin{verbatim}
  myapp: main.o f1.o f2.o
  main.o: main.c h1.h
  f1.o: f1.c h1.h h2.h
  f2.o: f2.c h2.h h3.h
\end{verbatim}

有了依赖关系，要真正的进行动作还要通过依赖规则，依赖规则必须以一个制表符开始，以
示和依赖关系的区别。于是我们可以把依赖规则加在上面的例子中：
\begin{verbatim}
  myapp: main.o f1.o f2.o
      gcc main.o f1.o f2.o -o myapp
  main.o: main.c h1.h
      gcc -c main.c
  f1.o: f1.c h1.h h2.h
      gcc -c f1.c
  f2.o: f2.c h2.h h3.h
      gcc -c f2.c
\end{verbatim}

Makefile文件中允许有注释，注释的符号是\#，作用范围是一行，虽然相比C源代码
Makefile不是很长，但是必要的注释仍然是需要的。

Makefile文件中也可以定义变量，变量的定义不需额外的关键字，直接赋值即可，引用变量
时需要用\verb=$(var-name)=的方式。
一般为了简化Makefile文件的写法或者增强程序的可移植
性，会把编译器、编译参数等内容定义为一个变量，这样在修改相应的参数是只需要修改定
义就可以了，比如我们可以把前面的例子改写为：
\begin{verbatim}
  PRONAME = myapp
  CC = gcc
  CFLAGS = -g -Wall
  
  $(PRONAME): main.o f1.o f2.o
      $(CC) main.o f1.o f2.o -o myapp
  main.o: main.c h1.h
      $(CC) $(CFLAGS) -c main.c
  f1.o: f1.c h1.h h2.h
      $(CC) $(CFLAGS) -c f1.c
  f2.o: f2.c h2.h h3.h
      $(CC) $(CFLAGS) -c f2.c
\end{verbatim}
Makefile的功能很强大，和automake和configure配合使用几乎成为当前Linux系统下软件编
译管理和发布的标准，本节介绍的只是make的一小部分功能，用来帮助我们自动编译我们的
程序。随着学习的深入，必定会需要更多的功能，关于更多的介绍请参考相关的资料。

\section{CVS版本控制系统}
CVS版本控制系统是开源社区的另一个标准工具，多个开发人员通过一个中心版本控制系统
来记录文件版本，从而达到保证文件同步的目的。关于版本控制的必要性本书不在赘述，这
里介绍一下CVS的基本功能的使用方法。

\begin{itemize}
\item 添加新的项目
\begin{verbatim}
  cvs import -m "write some comments here" project_name \
  vendor_tag release_tag
\end{verbatim}
  执行后：会将所有源文件及目录导入到/path/to/cvsroot/project\_name目录下。其中，
  \verb=vender_tag=是开发商标记，\verb=release_tag=是版本发布标记。
  这个命令将会把当前目录下所有的文件导入CVS仓库。
\item 日常使用（箭头后的命令是缩写方式）
  \begin{itemize}
  \item cvs checkout $\rightarrow$ cvs co：从CVS仓库检出；
  \item cvs commit $\rightarrow$ cvs ci：向CVS仓库检入；
  \item cvs add：添加新文件或目录；
  \item cvs remove $\rightarrow$ cvs rm：删除文件或目录；
  \end{itemize}
  add和rm之后别忘了commit。  
  如果是添加二进制文件，记得使用这个参数：  
  \verb=cvs add -kb <binaryfile>=
\item 查看修改历史
\begin{verbatim}
  cvs log file_name
  cvs history file_name
\end{verbatim}
\item 查看当前文件不同版本的区别
\begin{verbatim}
  cvs diff -c -r 1.3 -r 1.5 file_name
\end{verbatim}
\item 查看当前文件（可能已经修改了）和库中相应文件的区别
\begin{verbatim}
  cvs diff file_name
\end{verbatim}
\item 打标签
\begin{verbatim}
  cvs rtag [ -r <branch_tag_name> ] <tag_name> \
  <module_name>
\end{verbatim}
对当前的代码版本打标签。
\item 查看文件的当前标签
\begin{verbatim}
  cvs status -v <filename>
\end{verbatim}
\item 查看commit logs
\begin{verbatim}
  cvs log <filename> | more
\end{verbatim}
\item 导出某个标签的版本
\begin{verbatim}
  cvs co -r <tag_name> <module_name>
\end{verbatim}
\item 建立分支
\begin{verbatim}
  cvs rtag -b [ -r <base_branch_name> ] <new_branch_name>\
  <module_name>
\end{verbatim}
\end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "~/now-working/document/opensource/godsonCguide/main"
%%% End: 



